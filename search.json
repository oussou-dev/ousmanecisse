[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Ousmanecisse",
    "section": "",
    "text": "This is a Quarto website.\nTo learn more about Quarto websites visit https://quarto.org/docs/websites."
  },
  {
    "objectID": "courses.html",
    "href": "courses.html",
    "title": "Self-Study Courses",
    "section": "",
    "text": "Here you can find the various self-study courses I am currently following or have completed.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAI Dev Tools by Zoomcamp\n\n\n6 min\n\n\nMy learning notes and progress for the AI Dev Tools course.\n\n\n\nNov 28, 2025\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "courses/ai-dev-tools.html",
    "href": "courses/ai-dev-tools.html",
    "title": "AI Dev Tools by Zoomcamp",
    "section": "",
    "text": "This page documents my progress in the AI Dev Tools by Zoomcamp course.\n\n\n\n\n\n\nSet up the environment\nIntroduction to AI development tools\n\nAI-assisted development with Snake game example (React + JS)\nChat applications: ChatGPT, Claude, DeepSeek, Microsoft Copilot\nCoding assistants / IDEs: Claude Code, GitHub Copilot, Cursor, Pear\nProject bootstrappers: Bolt, Lovable\nAgents: Anthropic Computer Use, PR Agent, others\nHomework : build a Todo app in Django using AI tools\n\n\n\n\nThis first week of the AI Dev Tools Zoomcamp helped me lay the foundations of AI-assisted coding — i.e. adopting tools and workflows that make code writing faster, cleaner, and more efficient. Here are the main takeaways:\nThe course introduced me to the concept of “Vibe Coding” — leveraging AI assistants, coding-assist tools, project bootstrappers, and even automated agents to accelerate development rather than reinvent the wheel.\nI discovered a concrete landscape of current tools: AI-powered code assistants / IDEs (like GitHub Copilot, Cursor, Claude Code, etc.), as well as project generators (“bootstrappers”) such as Bolt or Lovable, which let you rapidly scaffold a new app.\nThe methodology is hands-on: right away we work on a small project (a Snake game in React + JS), using these AI tools to see their real benefit in a development context.\nA key message from the course: you don’t need prior AI knowledge to begin. If you already know a programming language (Python, JavaScript…), that’s enough to start benefiting from AI assistants.\nWhat struck me: the potential of a modern, AI-integrated dev workflow — combining assistants, agents, automation — to reduce friction, speed up prototyping or production phases, and free mental bandwidth for architecture, business logic, and code quality.\nIn short — Week 1 helped me shift away from the “hand-code everything” paradigm toward a more fluid, developer-AI collaborative approach that feels well-suited for modern software projects.\nHomework: Todo app in Django using AI tools\n\n\n\n\n\n\n\nUse a coding assistant for an end-to-end project\nBuild Snake in React/TS\nDefine API with OpenAPI\nGenerate FastAPI server from OpenAPI specs\nAdd CI/CD\nDeploy the application\nHomework : End-To-End Project - Online Coding Interview Platform\n\n\n\n\nThis week took my understanding of AI-assisted development to the next level by building a complete end-to-end application — from frontend to backend, database, containerization, and cloud deployment. Here’s what I learned:\n\n\nWe started by using Lovable (or similar AI tools like Bolt, Cursor, or Claude Code) to rapidly scaffold a multiplayer Snake game in React with TypeScript. The key insight: rather than starting with backend logic, we built an interactive frontend first, complete with mockups for authentication, leaderboards, and live gameplay. This frontend-first strategy shifts how you think about API contracts — you build the UI you want, then design the backend to serve it.\nThe prompt engineering for frontend was crucial: describing the app’s features (game modes, multiplayer mechanics, testing coverage) helped the AI generate a cohesive, testable codebase. The lesson: clear requirements lead to better code generation.\n\n\n\nOnce the frontend was done, we didn’t write the backend arbitrarily. Instead, we:\n\nExtracted OpenAPI specifications from the frontend code — documenting what API endpoints and data structures the frontend actually needs\nGenerated a FastAPI backend directly from those specs\n\nThis “API contract first” approach ensures frontend and backend stay synchronized and prevents wasted effort on unused endpoints. I learned that OpenAPI is a powerful bridge between AI-generated frontend and backend — it forces both to speak the same language.\n\n\n\nInitially we mocked the database, then we integrated SQLAlchemy with PostgreSQL and SQLite. This introduced important real-world considerations:\n\nIntegration testing: We wrote separate integration tests (not just unit tests) that spin up a SQLite database and verify the full data flow works\nSchema management & migrations: Real databases require careful handling of data persistence and schema changes\nTesting strategy: Mock databases for unit tests, real databases for integration tests\n\nI realized that many junior developers skip this, but it’s critical for production apps.\n\n\n\nWe containerized everything using Docker Compose, bundling:\n\nFrontend (served via Nginx)\nBackend (FastAPI)\nDatabase (PostgreSQL)\n\nThis forced me to think about: - Environment configuration - Service networking and communication - Build processes and dependencies - Running everything locally in a reproducible way\nRunning docker-compose up --build felt like magic — suddenly an entire application stack worked locally, exactly as it would in production.\n\n\n\nWe deployed to Render, combining frontend and backend into a single container. The workflow:\n\nBuild a single Docker image with both services\nPush to a cloud platform (we chose Render for simplicity)\nLet the platform handle scaling, SSL, and management\n\nThis demystified “DevOps” — it’s really just containerizing intelligently and picking a platform that abstracts infrastructure away.\n\n\n\nThe final piece was automating everything:\n\nRun tests (frontend + backend) on every push\nRun integration tests separately\nDeploy automatically to Render if tests pass\n\nThis creates a safety net — bad code can’t accidentally get deployed. We learned that CI/CD pipelines, while seeming complex at first, are just a series of automated checks and deployments.\n\n\n\n\nLeverage AI for speed, but maintain structure: AI can scaffold code fast, but without proper API contracts (OpenAPI), testing (unit + integration), and containerization, it falls apart at scale\nAPIs are the contract: OpenAPI specs bridge frontend and backend teams/tools — treat them seriously\nTesting isn’t optional: Unit tests catch bugs, integration tests catch integration bugs. Both matter\nContainerization enables reproducibility: Docker/Compose makes “it works on my machine” a non-issue\nAutomation frees mental energy: CI/CD means you can focus on features, not manual testing and deployment\nEnd-to-end thinking: You can’t just build a feature in isolation anymore. You need to think: frontend → API → backend → database → tests → deployment\n\n\n\n\nWeek 1 taught me AI tools exist. Week 2 taught me how to think like a real engineer using those tools: designing APIs, writing tests, containerizing, and automating. It’s the difference between “I can generate code” and “I can ship production applications.”\nHomework: End-to-End Project - Online Coding Interview Platform\nThe app can be able to do the following:\n\nCreate a link and share it with candidates\nAllow everyone who connects to edit code in the code panel\nShow real-time updates to all connected users\nSupport syntax highlighting for multiple languages\nExecute code safely in the browser"
  },
  {
    "objectID": "courses/ai-dev-tools.html#week-1-introduction-setup-ai-tools-overview",
    "href": "courses/ai-dev-tools.html#week-1-introduction-setup-ai-tools-overview",
    "title": "AI Dev Tools by Zoomcamp",
    "section": "",
    "text": "Set up the environment\nIntroduction to AI development tools\n\nAI-assisted development with Snake game example (React + JS)\nChat applications: ChatGPT, Claude, DeepSeek, Microsoft Copilot\nCoding assistants / IDEs: Claude Code, GitHub Copilot, Cursor, Pear\nProject bootstrappers: Bolt, Lovable\nAgents: Anthropic Computer Use, PR Agent, others\nHomework : build a Todo app in Django using AI tools\n\n\n\n\nThis first week of the AI Dev Tools Zoomcamp helped me lay the foundations of AI-assisted coding — i.e. adopting tools and workflows that make code writing faster, cleaner, and more efficient. Here are the main takeaways:\nThe course introduced me to the concept of “Vibe Coding” — leveraging AI assistants, coding-assist tools, project bootstrappers, and even automated agents to accelerate development rather than reinvent the wheel.\nI discovered a concrete landscape of current tools: AI-powered code assistants / IDEs (like GitHub Copilot, Cursor, Claude Code, etc.), as well as project generators (“bootstrappers”) such as Bolt or Lovable, which let you rapidly scaffold a new app.\nThe methodology is hands-on: right away we work on a small project (a Snake game in React + JS), using these AI tools to see their real benefit in a development context.\nA key message from the course: you don’t need prior AI knowledge to begin. If you already know a programming language (Python, JavaScript…), that’s enough to start benefiting from AI assistants.\nWhat struck me: the potential of a modern, AI-integrated dev workflow — combining assistants, agents, automation — to reduce friction, speed up prototyping or production phases, and free mental bandwidth for architecture, business logic, and code quality.\nIn short — Week 1 helped me shift away from the “hand-code everything” paradigm toward a more fluid, developer-AI collaborative approach that feels well-suited for modern software projects.\nHomework: Todo app in Django using AI tools"
  },
  {
    "objectID": "courses/ai-dev-tools.html#week-2-iend-to-end-project",
    "href": "courses/ai-dev-tools.html#week-2-iend-to-end-project",
    "title": "AI Dev Tools by Zoomcamp",
    "section": "",
    "text": "Use a coding assistant for an end-to-end project\nBuild Snake in React/TS\nDefine API with OpenAPI\nGenerate FastAPI server from OpenAPI specs\nAdd CI/CD\nDeploy the application\nHomework : End-To-End Project - Online Coding Interview Platform\n\n\n\n\nThis week took my understanding of AI-assisted development to the next level by building a complete end-to-end application — from frontend to backend, database, containerization, and cloud deployment. Here’s what I learned:\n\n\nWe started by using Lovable (or similar AI tools like Bolt, Cursor, or Claude Code) to rapidly scaffold a multiplayer Snake game in React with TypeScript. The key insight: rather than starting with backend logic, we built an interactive frontend first, complete with mockups for authentication, leaderboards, and live gameplay. This frontend-first strategy shifts how you think about API contracts — you build the UI you want, then design the backend to serve it.\nThe prompt engineering for frontend was crucial: describing the app’s features (game modes, multiplayer mechanics, testing coverage) helped the AI generate a cohesive, testable codebase. The lesson: clear requirements lead to better code generation.\n\n\n\nOnce the frontend was done, we didn’t write the backend arbitrarily. Instead, we:\n\nExtracted OpenAPI specifications from the frontend code — documenting what API endpoints and data structures the frontend actually needs\nGenerated a FastAPI backend directly from those specs\n\nThis “API contract first” approach ensures frontend and backend stay synchronized and prevents wasted effort on unused endpoints. I learned that OpenAPI is a powerful bridge between AI-generated frontend and backend — it forces both to speak the same language.\n\n\n\nInitially we mocked the database, then we integrated SQLAlchemy with PostgreSQL and SQLite. This introduced important real-world considerations:\n\nIntegration testing: We wrote separate integration tests (not just unit tests) that spin up a SQLite database and verify the full data flow works\nSchema management & migrations: Real databases require careful handling of data persistence and schema changes\nTesting strategy: Mock databases for unit tests, real databases for integration tests\n\nI realized that many junior developers skip this, but it’s critical for production apps.\n\n\n\nWe containerized everything using Docker Compose, bundling:\n\nFrontend (served via Nginx)\nBackend (FastAPI)\nDatabase (PostgreSQL)\n\nThis forced me to think about: - Environment configuration - Service networking and communication - Build processes and dependencies - Running everything locally in a reproducible way\nRunning docker-compose up --build felt like magic — suddenly an entire application stack worked locally, exactly as it would in production.\n\n\n\nWe deployed to Render, combining frontend and backend into a single container. The workflow:\n\nBuild a single Docker image with both services\nPush to a cloud platform (we chose Render for simplicity)\nLet the platform handle scaling, SSL, and management\n\nThis demystified “DevOps” — it’s really just containerizing intelligently and picking a platform that abstracts infrastructure away.\n\n\n\nThe final piece was automating everything:\n\nRun tests (frontend + backend) on every push\nRun integration tests separately\nDeploy automatically to Render if tests pass\n\nThis creates a safety net — bad code can’t accidentally get deployed. We learned that CI/CD pipelines, while seeming complex at first, are just a series of automated checks and deployments.\n\n\n\n\nLeverage AI for speed, but maintain structure: AI can scaffold code fast, but without proper API contracts (OpenAPI), testing (unit + integration), and containerization, it falls apart at scale\nAPIs are the contract: OpenAPI specs bridge frontend and backend teams/tools — treat them seriously\nTesting isn’t optional: Unit tests catch bugs, integration tests catch integration bugs. Both matter\nContainerization enables reproducibility: Docker/Compose makes “it works on my machine” a non-issue\nAutomation frees mental energy: CI/CD means you can focus on features, not manual testing and deployment\nEnd-to-end thinking: You can’t just build a feature in isolation anymore. You need to think: frontend → API → backend → database → tests → deployment\n\n\n\n\nWeek 1 taught me AI tools exist. Week 2 taught me how to think like a real engineer using those tools: designing APIs, writing tests, containerizing, and automating. It’s the difference between “I can generate code” and “I can ship production applications.”\nHomework: End-to-End Project - Online Coding Interview Platform\nThe app can be able to do the following:\n\nCreate a link and share it with candidates\nAllow everyone who connects to edit code in the code panel\nShow real-time updates to all connected users\nSupport syntax highlighting for multiple languages\nExecute code safely in the browser"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  }
]